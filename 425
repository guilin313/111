import os
import matplotlib.pyplot as plt
from tensorboard.backend.event_processing import event_accumulator

# è®¾ç½®æ—¥å¿—ç›®å½•ï¼ˆå¯æ”¹ä¸ºä½ è‡ªå·±çš„ï¼‰
log_root = './logs_unetr_affinity3d2'
runs = [log_root]  # ç›´æ¥åŠ è½½è¯¥ç›®å½•ä½œä¸ºä¸€ä¸ª run

# è¾“å‡ºç›®å½•
output_dir = os.path.join(os.getcwd(), 'scalar')
os.makedirs(output_dir, exist_ok=True)

colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']

# æ”¶é›† scalar å
scalar_set = set()
for run in runs:
    print(f"ğŸ” æ­£åœ¨åŠ è½½ run: {run}")
    ea = event_accumulator.EventAccumulator(run)
    try:
        ea.Reload()
        scalars = ea.Tags().get('scalars', [])
        print(f"âœ… æ‰¾åˆ° {len(scalars)} ä¸ª scalar: {scalars}")
        scalar_set.update(scalars)
    except Exception as e:
        print(f"âŒ åŠ è½½å¤±è´¥: {e}")

scalar_list = sorted(list(scalar_set))

# å±•ç¤º scalar é€‰é¡¹
print("\nğŸ“‹ æ‰€æœ‰å¯é€‰ scalar åï¼š")
for i, name in enumerate(scalar_list):
    print(f"[{i+1}] {name}")

# ç”¨æˆ·è¾“å…¥é€‰æ‹©
selected_idx = input("\nè¯·è¾“å…¥ä½ æƒ³ç”»çš„ scalar ç¼–å·ï¼ˆå¦‚ 1,3ï¼‰ï¼š")
selected_scalars = [scalar_list[int(i.strip()) - 1] for i in selected_idx.split(',') if i.strip().isdigit()]

# å¼€å§‹ç”»å›¾å¹¶ä¿å­˜
for scalar_name in selected_scalars:
    plt.figure(figsize=(8, 8))  # âœ… æ­£æ–¹å½¢å›¾åƒ
    has_data = False
    for idx, run in enumerate(runs):
        ea = event_accumulator.EventAccumulator(run)
        ea.Reload()
        if scalar_name not in ea.Tags().get('scalars', []):
            print(f"âš ï¸ run ä¸­æ²¡æœ‰ {scalar_name}")
            continue
        events = ea.Scalars(scalar_name)
        steps = [e.step for e in events]
        values = [e.value for e in events]
        if steps:
            has_data = True
            plt.plot(steps, values, label=os.path.basename(run), color=colors[idx % len(colors)])

    if has_data:
        plt.title(scalar_name)
        plt.xlabel('Step')
        plt.ylabel(scalar_name)
        plt.legend()
        plt.grid(True)
        plt.tight_layout()

        filename = scalar_name.replace("/", "_") + '.png'
        output_path = os.path.join(output_dir, filename)
        plt.savefig(output_path, dpi=100, bbox_inches='tight')  # âœ… 800x800åƒç´  + å»è¾¹
        print(f"âœ… å·²ä¿å­˜ï¼š{output_path}")
    else:
        print(f"ğŸš« æ²¡æœ‰æ•°æ®å¯ç”»ï¼š{scalar_name}")




import os
import matplotlib.pyplot as plt
from tensorboard.backend.event_processing import event_accumulator

log_root = './logs_unetr_affinity3d2'  # ä½ çš„ç›®å½•
runs = [log_root]
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']
output_dir = os.path.join(os.getcwd(), 'scalar')
os.makedirs(output_dir, exist_ok=True)

scalar_set = set()
for run in runs:
    print(f"ğŸ” æ­£åœ¨åŠ è½½ run: {run}")
    ea = event_accumulator.EventAccumulator(run)
    try:
        ea.Reload()
        scalars = ea.Tags().get('scalars', [])
        print(f"âœ… æ‰¾åˆ° {len(scalars)} ä¸ª scalar: {scalars}")
        scalar_set.update(scalars)
    except Exception as e:
        print(f"âŒ åŠ è½½å¤±è´¥: {e}")

scalar_list = sorted(list(scalar_set))
print("\nğŸ“‹ æ‰€æœ‰å¯é€‰ scalar åï¼š")
for i, name in enumerate(scalar_list):
    print(f"[{i+1}] {name}")

selected_idx = input("\nè¯·è¾“å…¥ä½ æƒ³ç”»çš„ scalar ç¼–å·ï¼ˆå¦‚ 1,3ï¼‰ï¼š")
selected_scalars = [scalar_list[int(i.strip()) - 1] for i in selected_idx.split(',') if i.strip().isdigit()]

for scalar_name in selected_scalars:
    plt.figure(figsize=(10, 6))
    has_data = False
    for idx, run in enumerate(runs):
        ea = event_accumulator.EventAccumulator(run)
        ea.Reload()
        if scalar_name not in ea.Tags().get('scalars', []):
            print(f"âš ï¸ run ä¸­æ²¡æœ‰ {scalar_name}")
            continue
        events = ea.Scalars(scalar_name)
        steps = [e.step for e in events]
        values = [e.value for e in events]
        if steps:
            has_data = True
            plt.plot(steps, values, label=os.path.basename(run), color=colors[idx % len(colors)])
    if has_data:
        plt.title(scalar_name)
        plt.xlabel('Step')
        plt.ylabel(scalar_name)
        plt.legend()
        plt.grid(True)
        plt.tight_layout()
        output_path = os.path.join(output_dir, scalar_name.replace('/', '_') + '.png')
        plt.savefig(output_path)
        print(f"âœ… å·²ä¿å­˜ï¼š{output_path}")
    else:
        print(f"ğŸš« æ²¡æœ‰æ•°æ®å¯ç”»ï¼š{scalar_name}")




events.out.tfevents.1744773167.guilin-System-Product-Name.672768.0
logs_unetr_affinity3d2


import os
import matplotlib.pyplot as plt
from tensorboard.backend.event_processing import event_accumulator

log_root = './logs'
runs = [d for d in os.listdir(log_root) if os.path.isdir(os.path.join(log_root, d))]
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']

# è¾“å‡ºæ–‡ä»¶å¤¹
output_dir = os.path.join(os.getcwd(), 'scalar')
os.makedirs(output_dir, exist_ok=True)

# æ”¶é›†æ‰€æœ‰ scalar å
scalar_set = set()

print("\nğŸ” æ­£åœ¨æ‰«ææ‰€æœ‰ scalar å...\n")
for run in runs:
    run_path = os.path.join(log_root, run)
    ea = event_accumulator.EventAccumulator(run_path)
    try:
        ea.Reload()
        scalars = ea.Tags().get('scalars', [])
        scalar_set.update(scalars)
        print(f"âœ… run={run} ä¸­å‘ç° {len(scalars)} ä¸ª scalar")
    except Exception as e:
        print(f"âš ï¸ run={run} åŠ è½½å¤±è´¥ï¼š{e}")

# æ˜¾ç¤ºå¯é€‰ scalar å
scalar_list = sorted(list(scalar_set))
print("\nğŸ“‹ æ‰€æœ‰å¯é€‰ scalar åï¼š")
for i, name in enumerate(scalar_list):
    print(f"[{i+1}] {name}")

# ç”¨æˆ·è¾“å…¥é€‰æ‹©
selected_idx = input("\nè¯·è¾“å…¥ä½ æƒ³ç”»çš„ scalar ç¼–å·ï¼ˆç”¨é€—å·åˆ†éš”ï¼Œå¦‚ 1,3,5ï¼‰ï¼š")
selected_scalars = [scalar_list[int(i.strip()) - 1] for i in selected_idx.split(',') if i.strip().isdigit()]

print(f"\nğŸ¯ ä½ é€‰æ‹©çš„ scalars: {selected_scalars}\n")

# ç”»å›¾
for scalar_name in selected_scalars:
    plt.figure(figsize=(10, 6))
    has_data = False
    for idx, run in enumerate(runs):
        run_path = os.path.join(log_root, run)
        ea = event_accumulator.EventAccumulator(run_path)
        try:
            ea.Reload()
            if scalar_name not in ea.Tags().get('scalars', []):
                print(f"âš ï¸ run={run} ä¸­æ²¡æœ‰ {scalar_name}")
                continue
            events = ea.Scalars(scalar_name)
            steps = [e.step for e in events]
            values = [e.value for e in events]
            if steps:
                has_data = True
                plt.plot(steps, values, label=run, color=colors[idx % len(colors)])
        except Exception as e:
            print(f"âš ï¸ run={run} è¯»å–å¤±è´¥ï¼š{e}")

    if has_data:
        plt.title(f'{scalar_name} over Steps')
        plt.xlabel('Step')
        plt.ylabel(scalar_name)
        plt.legend()
        plt.grid(True)
        plt.tight_layout()
        filename = scalar_name.replace("/", "_") + '.png'
        output_path = os.path.join(output_dir, filename)
        plt.savefig(output_path)
        print(f"âœ… å›¾åƒå·²ä¿å­˜ï¼š{output_path}")
    else:
        print(f"ğŸš« æ²¡æœ‰æ•°æ®å¯ç”»ï¼š{scalar_name}")



import os
import matplotlib.pyplot as plt
from tensorboard.backend.event_processing import event_accumulator

log_root = './logs'
scalars_to_plot = ['loss', 'val/loss', 'accuracy', 'lr']
runs = [d for d in os.listdir(log_root) if os.path.isdir(os.path.join(log_root, d))]
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']

# åˆ›å»º scalar è¾“å‡ºæ–‡ä»¶å¤¹
output_dir = os.path.join(os.getcwd(), 'scalar')
os.makedirs(output_dir, exist_ok=True)

for scalar_name in scalars_to_plot:
    plt.figure(figsize=(10, 6))
    for idx, run in enumerate(runs):
        run_path = os.path.join(log_root, run)
        ea = event_accumulator.EventAccumulator(run_path)
        ea.Reload()

        if scalar_name not in ea.Tags()['scalars']:
            print(f"âš ï¸ {scalar_name} ä¸å­˜åœ¨äº {run_path}")
            continue

        events = ea.Scalars(scalar_name)
        steps = [e.step for e in events]
        values = [e.value for e in events]

        if len(steps) > 0:
            plt.plot(steps, values, label=run, color=colors[idx % len(colors)])

    plt.title(f'{scalar_name} over Steps')
    plt.xlabel('Step')
    plt.ylabel(scalar_name)
    if plt.gca().has_data():
        plt.legend()
    plt.grid(True)
    plt.tight_layout()
    output_path = os.path.join(output_dir, f'{scalar_name.replace("/", "_")}.png')
    plt.savefig(output_path)
    print(f'âœ… å›¾åƒå·²ä¿å­˜ï¼š{output_path}')



UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.
  plt.legend()


import os
import matplotlib.pyplot as plt
from tensorboard.backend.event_processing import event_accumulator

# è®¾ç½® TensorBoard æ—¥å¿—æ ¹ç›®å½•
log_root = './logs'

# ä½ è¦ç”»çš„ scalar åç§°ï¼ˆåŒ…æ‹¬ lrã€lossã€accuracy ç­‰ï¼‰
scalars_to_plot = ['loss', 'val/loss', 'accuracy', 'lr']  # åŠ ä¸Šå­¦ä¹ ç‡ lr

# éå†æ‰€æœ‰ runsï¼ˆå­ç›®å½•ï¼‰
runs = [d for d in os.listdir(log_root) if os.path.isdir(os.path.join(log_root, d))]

# é¢œè‰²åˆ—è¡¨
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']

for scalar_name in scalars_to_plot:
    plt.figure(figsize=(10, 6))
    for idx, run in enumerate(runs):
        run_path = os.path.join(log_root, run)

        # åŠ è½½ TensorBoard çš„ event æ–‡ä»¶
        ea = event_accumulator.EventAccumulator(run_path)
        ea.Reload()

        if scalar_name not in ea.Tags()['scalars']:
            print(f"âš ï¸ {scalar_name} ä¸å­˜åœ¨äº {run_path}")
            continue

        events = ea.Scalars(scalar_name)
        steps = [e.step for e in events]
        values = [e.value for e in events]

        plt.plot(steps, values, label=run, color=colors[idx % len(colors)])

    plt.title(f'{scalar_name} over Steps')
    plt.xlabel('Step')
    plt.ylabel(scalar_name)
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.savefig(f'{scalar_name}.png')
    print(f'âœ… å›¾åƒå·²ä¿å­˜ï¼š{scalar_name}.png')
    # plt.show()  # å¦‚æœä½ å¸Œæœ›ç›´æ¥å¼¹å‡ºçª—å£çœ‹å›¾ï¼Œå¯ä»¥å–æ¶ˆæ³¨é‡Š



import os
import tifffile
import numpy as np
from PIL import Image

# å››ä¸ª.tifæ–‡ä»¶è·¯å¾„ï¼ˆç°åº¦å’Œå½©è‰²æ··åˆéƒ½æ”¯æŒï¼‰
tif_paths = [
    '/path/to/file1.tif',
    '/path/to/file2.tif',
    '/path/to/file3.tif',
    '/path/to/file4.tif',
]

gap = 10  # å›¾ç‰‡é—´ç™½è‰²é—´éš™ï¼ˆåƒç´ ï¼‰

def to_rgb_array(img):
    """å°†å›¾åƒæ ‡å‡†åŒ–ä¸º RGB"""
    if img.ndim == 2:
        return np.stack([img]*3, axis=-1)
    elif img.ndim == 3:
        if img.shape[2] == 1:
            return np.concatenate([img]*3, axis=-1)
        elif img.shape[2] == 3:
            return img
        elif img.shape[2] == 4:
            return img[:, :, :3]
    raise ValueError("Unsupported image format.")

# è¯»å–å›¾åƒå¹¶è½¬ä¸ºRGB
images = []
for path in tif_paths:
    img_stack = tifffile.imread(path)
    first_slice = img_stack[0] if img_stack.ndim >= 3 else img_stack
    rgb_img = to_rgb_array(first_slice)
    images.append(rgb_img.astype(np.uint8))

# è½¬ä¸º PIL å›¾åƒ
pil_images = [Image.fromarray(img) for img in images]

# è®¡ç®—æ€»å®½åº¦ï¼ˆåŒ…æ‹¬é—´éš™ï¼‰
height = max(img.height for img in pil_images)
total_width = sum(img.width for img in pil_images) + gap * (len(pil_images) - 1)

# åˆ›å»ºæ–°ç”»å¸ƒï¼ˆç™½åº•ï¼‰
result = Image.new("RGB", (total_width, height), color=(255, 255, 255))

# æ‹¼æ¥å›¾åƒ
x_offset = 0
for i, img in enumerate(pil_images):
    result.paste(img, (x_offset, 0))
    x_offset += img.width + gap

# åˆ›å»ºè¾“å‡ºæ–‡ä»¶å¤¹
output_dir = os.path.join(os.getcwd(), 'concat')
os.makedirs(output_dir, exist_ok=True)

# ä¿å­˜ä¸º PNG
output_path = os.path.join(output_dir, 'concat_output.png')
result.save(output_path)

print(f"âœ… æ‹¼æ¥å®Œæˆï¼Œå·²ä¿å­˜åˆ°ï¼š{output_path}")



import os
import tifffile
import numpy as np
from PIL import Image

# æŒ‡å®šå››ä¸ª tif å›¾åƒè·¯å¾„ï¼ˆç°åº¦å’Œå½©è‰²æ··åˆå‡å¯ï¼‰
tif_paths = [
    '/path/to/file1.tif',
    '/path/to/file2.tif',
    '/path/to/file3.tif',
    '/path/to/file4.tif',
]

def to_rgb_array(img):
    """ç¡®ä¿å›¾åƒä¸º RGB æ ¼å¼"""
    if img.ndim == 2:  # ç°åº¦å›¾
        return np.stack([img] * 3, axis=-1)
    elif img.ndim == 3:
        if img.shape[2] == 1:
            return np.concatenate([img] * 3, axis=-1)
        elif img.shape[2] == 3:
            return img
        elif img.shape[2] == 4:
            return img[:, :, :3]  # ä¸¢å¼ƒ alpha é€šé“
    raise ValueError("Unsupported image format.")

# è¯»å–å›¾åƒå¹¶è½¬æ¢ä¸º RGB
images = []
for path in tif_paths:
    img_stack = tifffile.imread(path)
    first_slice = img_stack[0] if img_stack.ndim >= 3 else img_stack
    rgb_img = to_rgb_array(first_slice)
    images.append(rgb_img)

# è½¬ä¸º PIL å›¾åƒ
pil_images = [Image.fromarray(img.astype(np.uint8)) for img in images]

# è®¡ç®—æ‹¼æ¥åå°ºå¯¸
height = max(img.height for img in pil_images)
total_width = sum(img.width for img in pil_images)

# æ‹¼æ¥å›¾åƒï¼ˆæ¨ªå‘ï¼‰
result = Image.new("RGB", (total_width, height))
x_offset = 0
for img in pil_images:
    result.paste(img, (x_offset, 0))
    x_offset += img.width

# åˆ›å»ºè¾“å‡ºç›®å½•
output_dir = os.path.join(os.getcwd(), 'concat')
os.makedirs(output_dir, exist_ok=True)

# ä¿å­˜ä¸º PNG
output_path = os.path.join(output_dir, 'concat_output.png')
result.save(output_path)

print(f"âœ… æ‹¼æ¥å®Œæˆï¼Œå·²ä¿å­˜ä¸º PNGï¼š{output_path}")
